/***************************************************************

							EFFECT PARSER

			1.Parse shader organization of each pass/technique
			from the token list generated by IEffectTokenizer

***********************************************************/
#pragma once

namespace NoiseEffectCompiler
{

		struct N_Shader
		{
			std::string entryPoint;
			std::string version;
		};

		//used in Unique shader unordered_set
		struct IShaderHasher
		{
			//functor
			size_t    operator()(N_Shader s) const
			{
				//std::hash<std::string>()() :::: invoke  () operator functor 
				//0xAAAAAAAA is the mask of 1,3,5,7,9... bit from L to R
				//0x55555555 is the mask of 2,4,6,8,10... bit from L to R
				return
					(std::hash<std::string>()(s.entryPoint) & 0xAAAAAAAA) |
					(std::hash<std::string>()(s.version) & 0x55555555);
			}
		};

		//used in Unique shader unordered_set
		struct IShaderComparator
		{
			bool operator()(const N_Shader& lhs,const N_Shader& rhs) const
			{
				return (lhs.entryPoint == rhs.entryPoint) && (lhs.version == rhs.version);
			}
		};



		//--------------------HIERARCHY----------------
		//	Effect
		//		|---Technique
		//		|			|---Pass
		//		|			|		|----VertexShader(crucial)
		//		|			|		|----PixelShader(crucial)
		//		|			|		|----GeometryShader(optional)
		//		|			|---Pass
		//		|			|		|----VertexShader(crucial)
		//		|			|		|----PixelShader(crucial)
		//		|			|		|----GeometryShader(optional)
		//		|			|  ...................
		//		|
		//		|---Technique
		//		|			|---Pass
		//		|			|		|   ...................
		//		|			|   ...................
		//		|
		//		| ...................
		//-----------------------------

		class IPass
		{
		public:

			void SetVS(N_Shader shader);

			void SetGS(N_Shader shader);

			void SetPS(N_Shader shader);

			void GetVS(N_Shader& outShader);

			void GetGS(N_Shader& outShader);

			void GetPS(N_Shader& outShader);

		private:

			N_Shader mVS;
			N_Shader mGS;
			N_Shader mPS;

		};


		class ITechnique : public IFactory<IPass>
		{
		public:

			//theoretically, pass count won't be limited,
			//but too many pass could cause performance overhead
			ITechnique() :IFactory<IPass>(32) {};

		private:
		};


		class IEffect : public IFactory<ITechnique>
		{
		public:

			//Root interface of Effect Framework, owns Technique child object
			//for a specific render effect
			IEffect() :IFactory<ITechnique>(100000) {};

		private:

		};


		class IEffectParser
		{
		public:

			IEffectParser();

			bool Parse(std::vector<N_TokenInfo>&& tokenList);//parse Effect (many techiniques)

			void GetHLSLFileList(std::vector<std::string>& outFileList);

			void GetCompilationPlan(std::vector<N_Shader>& outShaderList);//shaders that need compiling

		private:

			enum NOISE_SHADER_TYPE
			{
				NOISE_SHADER_TYPE_VS = 1,
				NOISE_SHADER_TYPE_PS = 2,
				NOISE_SHADER_TYPE_GS = 3,
			};

			UINT mTokenIndex;

			bool mFunction_ParseIncludeInstruction();

			bool mFunction_ParseTechnique();

			bool mFunction_ParsePass(ITechnique* pFatherTechnique);

			bool mFunction_ParseShaderConfig(IPass* pFatherPass, NOISE_SHADER_TYPE st);

			bool mFunction_MatchCurrentToken(TOKEN_TYPE type);

			bool	mFunction_MatchCurrentToken(TOKEN_TYPE type, const std::string& content);

			void mFunction_ReportError(const std::string& msg);

			std::vector<N_TokenInfo> mTokenList;//in

			std::vector<std::string> mSourceFileList;//out

			std::unordered_set<N_Shader,IShaderHasher,IShaderComparator> mUniqueShaderTable;//out

			IEffect		mEffect;//one file for one Effect

		};
}